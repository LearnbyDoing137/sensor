#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>

// 感測器通信參數
#define COM 0x55
#define BAUD_RATE 115200
#define TIMEOUT_MS 500
#define MAX_DISTANCE_CM 600.0

// 感測器引腳
#define RXD_LEFT 16 // UART2 RX
#define TXD_LEFT 17 // UART2 TX
HardwareSerial SerialSensorLeft(2);

#define RXD_RIGHT 18 // UART1 RX
#define TXD_RIGHT 19 // UART1 TX
HardwareSerial SerialSensorRight(1);

// Wi-Fi設置（作為客戶端連接AP）
const char* ssid = "ESP32_Webserver";
const char* password = "12345678";
const char* serverUrl = "http://192.168.40.1/update"; // 主ESP32地址

// 感測器數據
float currentDistanceLeft = -1.0;
float currentDistanceRight = -1.0;

// 緩衝區
unsigned char buffer_Left[4] = {0};
unsigned char buffer_Right[4] = {0};

// 讀取計時
unsigned long lastSensorReadTime = 0;

// 函數宣告
bool readSensorData(HardwareSerial &sensor, unsigned char *buffer);
bool validateChecksum(unsigned char *buffer);
float extractDistance(unsigned char *buffer);
void clearSerialBuffer(HardwareSerial &sensor);
void debugRawData(HardwareSerial &sensor, const char *sensorName);
void sendDataToServer();

void setup() {
  Serial.begin(BAUD_RATE);
  SerialSensorLeft.begin(BAUD_RATE, SERIAL_8N1, RXD_LEFT, TXD_LEFT);
  SerialSensorRight.begin(BAUD_RATE, SERIAL_8N1, RXD_RIGHT, TXD_RIGHT);

  // 連接Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connecting to WiFi...");
  }
  Serial.println("Connected to WiFi");
  delay(1000);
}

void loop() {
  if (millis() - lastSensorReadTime >= 1000) {
    // 讀取left
    SerialSensorLeft.write(COM);
    if (readSensorData(SerialSensorLeft, buffer_Left)) {
      if (validateChecksum(buffer_Left)) {
        float newDistance = extractDistance(buffer_Left);
        if (newDistance > 0.0 && newDistance <= MAX_DISTANCE_CM) {
          currentDistanceLeft = newDistance;
        }
      } else {
        Serial.println("Left: Checksum error");
        debugRawData(SerialSensorLeft, "Left");
      }
    } else {
      Serial.println("Left: No complete data received");
      debugRawData(SerialSensorLeft, "Left");
      clearSerialBuffer(SerialSensorLeft);
    }

    // 讀取right
    SerialSensorRight.write(COM);
    if (readSensorData(SerialSensorRight, buffer_Right)) {
      if (validateChecksum(buffer_Right)) {
        float newDistance = extractDistance(buffer_Right);
        if (newDistance > 0.0 && newDistance <= MAX_DISTANCE_CM) {
          currentDistanceRight = newDistance;
        }
      } else {
        Serial.println("Right: Checksum error");
        debugRawData(SerialSensorRight, "Right");
      }
    } else {
      Serial.println("Right: No complete data received");
      debugRawData(SerialSensorRight, "Right");
      clearSerialBuffer(SerialSensorRight);
    }

    // 在串口監視器中顯示距離
    Serial.print("Left: ");
    if (currentDistanceLeft < 0.0) {
      Serial.print("N/A");
    } else {
      Serial.print(currentDistanceLeft, 1);
    }
    Serial.print(" cm, Right: ");
    if (currentDistanceRight < 0.0) {
      Serial.print("N/A");
    } else {
      Serial.print(currentDistanceRight, 1);
    }
    Serial.println(" cm");

    // 發送數據到主ESP32
    sendDataToServer();

    lastSensorReadTime = millis();
  }
}

void sendDataToServer() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    http.begin(serverUrl);
    http.addHeader("Content-Type", "application/json");

    StaticJsonDocument<200> doc;
    doc["left"] = currentDistanceLeft;
    doc["right"] = currentDistanceRight;
    String json;
    serializeJson(doc, json);

    int httpCode = http.POST(json);
    if (httpCode > 0) {
      Serial.printf("HTTP POST code: %d\n", httpCode);
    } else {
      Serial.println("HTTP POST error");
    }
    http.end();
  } else {
    Serial.println("WiFi not connected");
  }
}

bool readSensorData(HardwareSerial &sensor, unsigned char *buffer) {
  unsigned long startTime = millis();
  while (sensor.available() < 4 && millis() - startTime < TIMEOUT_MS) {
    // 等待數據或超時
  }
  if (sensor.available() >= 4) {
    if (sensor.read() == 0xFF) {
      buffer[0] = 0xFF;
      for (int i = 1; i < 4; i++) {
        buffer[i] = sensor.read();
      }
      return true;
    } else {
      return false; // 第一個字節不是0xFF
    }
  }
  return false; // 數據不足
}

bool validateChecksum(unsigned char *buffer) {
  uint8_t cs = buffer[0] + buffer[1] + buffer[2];
  return buffer[3] == cs;
}

float extractDistance(unsigned char *buffer) {
  int distance_mm = (buffer[1] << 8) + buffer[2]; // 原始距離（毫米）
  return distance_mm / 10.0; // 轉換為厘米（浮點數）
}

void clearSerialBuffer(HardwareSerial &sensor) {
  while (sensor.available()) {
    sensor.read();
  }
}

void debugRawData(HardwareSerial &sensor, const char *sensorName) {
  Serial.print(sensorName);
  Serial.print(" Raw Data: ");
  if (sensor.available()) {
    while (sensor.available()) {
      Serial.print(sensor.read(), HEX);
      Serial.print(" ");
    }
  } else {
    Serial.print("No data");
  }
  Serial.println();
}
